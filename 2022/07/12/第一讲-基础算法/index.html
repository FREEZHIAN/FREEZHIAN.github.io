<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第一讲 基础算法 | 从前慢</title><meta name="keywords" content="算法基础"><meta name="author" content="至安"><meta name="copyright" content="至安"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一讲 基础算法 快速排序 快速排序  分解：以a[l]为基准元素将a[l:r]划分成3段a[l:q-1], a[q] 和 a[p+1: r],使得a[l:q-1]中任何一个元素小于等于a[q],而a[q+1:r]中任何一个元素大于等于a[q]。下标q在划分过程中确定。 递归求解：通过递归调用快速排序算法，分别对a[l:q-1]和a[q+1:r]进行排序。 合并：由于对a[l:q-1]和a[q+1">
<meta property="og:type" content="article">
<meta property="og:title" content="第一讲 基础算法">
<meta property="og:url" content="http://example.com/2022/07/12/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="从前慢">
<meta property="og:description" content="第一讲 基础算法 快速排序 快速排序  分解：以a[l]为基准元素将a[l:r]划分成3段a[l:q-1], a[q] 和 a[p+1: r],使得a[l:q-1]中任何一个元素小于等于a[q],而a[q+1:r]中任何一个元素大于等于a[q]。下标q在划分过程中确定。 递归求解：通过递归调用快速排序算法，分别对a[l:q-1]和a[q+1:r]进行排序。 合并：由于对a[l:q-1]和a[q+1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/any2.webp">
<meta property="article:published_time" content="2022-07-12T09:39:07.000Z">
<meta property="article:modified_time" content="2022-07-18T13:42:44.111Z">
<meta property="article:author" content="至安">
<meta property="article:tag" content="算法基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/any2.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/12/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 至安","link":"链接: ","source":"来源: 从前慢","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第一讲 基础算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-18 21:42:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom1.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/u.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/any2.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">从前慢</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第一讲 基础算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-12T09:39:07.000Z" title="发表于 2022-07-12 17:39:07">2022-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-18T13:42:44.111Z" title="更新于 2022-07-18 21:42:44">2022-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><strong>第一讲 基础算法</strong></h1>
<h2 id="快速排序"><strong>快速排序</strong></h2>
<h3 id="快速排序-2"><strong>快速排序</strong></h3>
<ol>
<li>分解：以a[l]为基准元素将<code>a[l:r]</code>划分成3段<code>a[l:q-1]</code>, <code>a[q]</code> 和 <code>a[p+1: r]</code>,使得<code>a[l:q-1]</code>中任何一个元素小于等于<code>a[q]</code>,而<code>a[q+1:r]</code>中任何一个元素大于等于<code>a[q]</code>。下标<code>q</code>在划分过程中确定。</li>
<li>递归求解：通过递归调用快速排序算法，分别对<code>a[l:q-1]</code>和<code>a[q+1:r]</code>进行排序。</li>
<li>合并：由于对<code>a[l:q-1]</code>和<code>a[q+1:r]</code>的排序是就地进行的，因此在<code>a[l:q-1]</code>和<code>a[q+1:r]</code>都已排好的序后，不需要执行任何计算，<code>a[l:r]</code>则已排好序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>   <span class="hljs-comment">//当数组内只有一个或没有元素时，递归结束</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>   <span class="hljs-comment">//分解</span><br>   <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = a[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>    <span class="hljs-comment">//递归求解</span><br>    <span class="hljs-built_in">quick_sort</span>(a, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(a, j+<span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="情况分析">情况分析</h4>
<ol>
<li>
<p><code>do i++; while(a[i] &lt; x)</code>和<code>do j--; while(a[j] &gt; x)</code>不能用<code>a[i] &lt;= x</code> 和 <code>a[j] &gt;= x</code>.假设<code>a[l:r]</code>全相    等则执行完<code>do i++; while(a[i] &lt;= x)</code>;之后,<code>i</code>会自增到<code>r+1</code>.然后继续执行<code>a[i] &lt;= x</code> 判断条件，造成数组下标 越界(但这貌似不会报错)并且如果之后的<code>a[i] &lt;= x</code> (此时<code>i &gt; r</code>) 条件也不幸成立，就会造成一直循环下去,造 成内存超限(Memory Limit Exceeded).</p>
</li>
<li>
<p><code>if(i &lt; j) swap(a[i], a[j])</code>能否使用 <code>i &lt;= j</code></p>
<p>可以使用<code>if(i &lt;= j) swap(a[i], a[j])</code>;</p>
<p>因为 <code>i = j</code> 时，交换一下<code>a[i],a[j]</code> 无影响，因为<code>a[i]=a[j]</code></p>
</li>
<li>
<p>当<code>x=a[l]</code>的边界情况<br>
当只有两个元素时例如4,5,这时按照代码执行下来,循环之后<code>i=l</code>,退出循环后<code>sort(l,i-1),sort(i,r);</code>等价于<code>sort(l,i-1),sort(l,r)</code>;这就跟进入递归时一样了,就导致了死循环,所以此时只能用<code>sort(l,j),sort(j+1,r)</code>;</p>
</li>
<li>
<p>当<code>x = a[r]</code>的边界情况<br>
道理类似,如果此时为5,4也会导致j=r,进行<code>sort(l,j),sort(j+1,r)</code>;导致死循环一直<code>sort(l,r)</code>,此时只能用<code>sort(l,i-1),sort(i,r)</code>;</p>
</li>
<li>
<p>当<code>x=a[l+r&gt;&gt;1]</code>的边界情况<br>
此时x取的是序列中间靠左的位置(<u>如果序列个数为奇,则取正中间,如果为偶,则取中间靠左</u>),此时如果元素个数为2,<br>
则中间靠左就是第1个元素,这时就跟<code>x=q[l]</code>的边界情况一致了,所以这时只能用<code>sort(l,j),sort(j+1,r)</code>;</p>
</li>
<li>
<p>当<code>x=a[l+r + 1&gt;&gt;1]</code>的边界情况<br>
此时x取的是序列中间靠右的情况,当元素只有两个情况就会类似<code>x=q[r]</code>,此时只能用<code>sort(l,i-1),sort(i,r)</code>;</p>
</li>
<li>
<p>如果<code>x=q[l] or x=q[l+r&gt;&gt;1]</code>此时只能用<code>sort(l,j),sort(j+1,r)</code>;<br>
如果<code>x=q[r] or x=q[l+r + 1&gt;&gt;1]</code>此时只能用<code>sort(l,i-1),sort(i,r)</code>;</p>
</li>
<li>
<p><strong>对于i来说,i的左边的值是确定的,一定小于等于x,对于j来说,j的右边的值是确定的,一定大于等于x,最后结束的时候<u><code>i &gt;= j</code></u>(i在j的右边或者相等)</strong></p>
</li>
<li>
<p>由于最后一轮的if语句一定不执行.所以只能保证<code>i &gt;= j</code>和<code>q[l:i-1] &lt;= x, q[i] &gt;= x</code>和<code>q[j+1:r] &gt;= x, q[j] &lt;= x</code></p>
<p>由<code>q[l..i-1] &lt;= x，i &gt;= j(i-1 &gt;= j-1)</code> 和 <code>q[j] &lt;= x</code> 可以得到 <code>q[l..j] &lt;= x</code>又因为<code>q[j+1..r] &gt;= x</code>所以，<code>q[l..j] &lt;=x,q[j+1..r] &gt;= x</code></p>
<p>​             <code>a[l : i - 1] &lt; x, a[i] &gt;=x, i &gt;= j</code></p>
<table>
<thead>
<tr>
<th>i - 1,     i， i + 1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a[j + 1 : r] &gt; x, a[j] &lt;= x</code></td>
</tr>
<tr>
<td>j - 1,    j,     j + 1</td>
</tr>
</tbody>
</table>
<p>推出<code>q[l:j] &lt;=x,q[j+1:r] &gt;= x, q[l : i - 1] &lt;= x, q[i : r] &gt;= x          </code></p>
</li>
</ol>
<h4 id="复杂度分析"><strong>复杂度分析</strong></h4>
<p>​            最坏为$$O(n^2)$$, 最好为$$O(nlogn)$$,快排平均时间复杂度最好，数组顺序越复			杂，效率越高</p>
<h3 id="第k个数">第k个数</h3>
<ol>
<li>
<p>分解：以a[l]为基准元素将<code>a[l:r]</code>划分成3段<code>a[l:q-1]</code>, <code>a[q]</code> 和 <code>a[p+1: r]</code>,使得<code>a[l:q-1]</code>中任何一个元素小于等于<code>a[q]</code>,而<code>a[q+1:r]</code>中任何一个元素大于等于<code>a[q]</code>。下标<code>q</code>在划分过程中确定。</p>
</li>
<li>
<p>递归求解：若左边数的个数大于k,即第k个数在左半段中，反之，在右半边。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//只有一个元素，输出目标值</span><br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> a[l];<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = a[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j - l + <span class="hljs-number">1</span> &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r, k - j + l - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(a, l, j, k); <br>&#125;<br><br><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="复杂度分析-2">复杂度分析</h4>
<p>​           最坏为$$O(n^2)$$, 最好为$$O(n)$$,快排平均时间复杂度最好，数组顺序越复杂，效率越高，和快排基本思想差不多。</p>
<h2 id="归并排序">归并排序</h2>
<h3 id="归并排序-2">归并排序</h3>
<p>​               归并排序的基本思想：将待排序元素分成大小大致相同的两个子集合，分   				别对两个子集合进行排序，最终将排好序的子集合合并成要求的排好序的				集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">//递归终止</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> ; <br>    <span class="hljs-comment">// 分解</span><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>     <span class="hljs-comment">//递归求解</span><br>    <span class="hljs-built_in">merge_sort</span>(a, l, mid), <span class="hljs-built_in">merge_sort</span>(a, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">//合并</span><br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = a[j++];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x1 = l, x2 = <span class="hljs-number">0</span>; x1 &lt;= r; x1++, x2++)<br>        a[x1] = tmp[x2];<br>&#125;    <br></code></pre></td></tr></table></figure>
<h4 id="复杂度分析-3">复杂度分析</h4>
<p>​       合并排序是一个渐进最优算法(因为它的时间下界为$$O(nlogn)$$)，时间复杂度为$$O(nlogn)$$;</p>
<h3 id="逆序对的数量">逆序对的数量</h3>
<h4 id="题目描述">题目描述</h4>
<p>​           给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。逆序对		定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其		为一个逆序对；否则不是。</p>
<p>​          <strong>输入格式</strong></p>
<p>​          第一行包含整数 n，表示数列的长度。</p>
<pre><code>	第二行包含 n 个整数，表示整个数列。
</code></pre>
<p>​          <strong>输出格式</strong><br>
​          输出一个整数，表示逆序对的个数。</p>
<p>​         <strong>数据范围</strong><br>
​         $$1≤ n ≤100000$$，<br>
​        数列中的元素的取值范围 $$[1,10^9]$$。</p>
<p>​        <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">6<br>2 3 4 5 6 1<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">5<br></code></pre></td></tr></table></figure>
<h4 id="解析">解析</h4>
<p>​           本题采用分治法。我们将序列从中间分开，将逆序对分成三类：</p>
<pre><code>           1. 逆序对都在左边
           2. 逆序对都在右边
           3. 逆序对一个在左，一个在右
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    ll lz = <span class="hljs-built_in">merge_sort</span>(a, l, mid);<span class="hljs-comment">//左</span><br>    ll rz = <span class="hljs-built_in">merge_sort</span>(a, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//右</span><br>    <span class="hljs-comment">//中</span><br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>, mz = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = a[j++];<br>            mz += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x1 = l, x2 = <span class="hljs-number">0</span>; x1 &lt;= r; x1++, x2++) a[x1] = tmp[x2];<br>    <span class="hljs-keyword">return</span> lz + rz + mz;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二分">二分</h2>
<h3 id="数的范围">数的范围</h3>
<h4 id="题目描述-2">题目描述</h4>
<p>​		 给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p>
<p>​		对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始 计		 		数）。</p>
<p>​		如果数组中不存在该元素，则返回 -1 -1。</p>
<p>​          <strong>输入格式</strong></p>
<p>​		  第一行包含整数 n 和 q，表示数组长度和询问个数。</p>
<p>​		第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p>
<p>​		接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p>
<p>​          <strong>输出格式</strong><br>
​        共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>​       如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<p>​         <strong>数据范围</strong></p>
<p>​		$$1≤n≤100000$$<br>
​		$$1≤q≤10000$$<br>
​		$$1≤k≤10000$$</p>
<p>​        <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3 4<br>5 5<br>-1 -1<br></code></pre></td></tr></table></figure>
<h4 id="解析-2">解析</h4>
<p>​      画个图便可得知</p>
<table>
<thead>
<tr>
<th>xl              mid                 xr</th>
</tr>
</thead>
</table>
<p>​            左侧求解方法   <code>if(a[mid] &gt;= x)   r = mid </code>    <code>else l  = mid + 1;</code></p>
<p>​            右侧求解方法   <code>if(a[mid] &lt;= x)   l = mid</code>    <code>else r  = mid + 1;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n, q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <br>   cin &gt;&gt; n &gt;&gt; q;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>   <span class="hljs-keyword">while</span>(q--) &#123;<br>      <span class="hljs-type">int</span> k; cin &gt;&gt; k;<br>      <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>          <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span>(a[mid] &gt;= k) r = mid;<br>          <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(a[l] != k) cout &lt;&lt;<span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">else</span> &#123;<br>          cout &lt;&lt; l &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>          l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[mid] &lt;= k) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; <br>           &#125;<br>         cout &lt;&lt; r &lt;&lt; endl;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数的三次方根">数的三次方根</h3>
<h4 id="题目描述-3">题目描述</h4>
<p>​	 给定一个浮点数 n，求它的三次方根。</p>
<p>​      <strong>输入格式</strong></p>
<p>​      共一行，包含一个浮点数 n。</p>
<p>​      <strong>输出格式</strong></p>
<p>​       共一行，包含一个浮点数，表示问题的解。</p>
<p>​       注意，结果保留 6 位小数。</p>
<p>​         <strong>数据范围</strong></p>
<p>​		$$−10000≤n≤10000$$</p>
<p>​        <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1000.00<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">10.000000<br></code></pre></td></tr></table></figure>
<h4 id="解析-3">解析</h4>
<p>​       题目要求保留六位小数，因此设置精度 <code>eps = 1e-8</code>, 即<code>r - l &lt; eps</code>;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">double</span> n; cin &gt;&gt; n;<br>  <span class="hljs-type">double</span> l = <span class="hljs-number">-10000.00</span>, r = <span class="hljs-number">10000.00</span>;<br>  <span class="hljs-keyword">while</span>(r - l &gt;= eps) &#123;<br>       <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2.0</span>;<br>       <span class="hljs-keyword">if</span>(mid * mid *mid &lt;= n) l = mid;<br>       <span class="hljs-keyword">else</span> r = mid;<br>  &#125;<br>  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>, l);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>​      <strong>上述三道例题是运用分治法解决的</strong></p>
<p>​       1.二分的范围 ： 通常 <code>l + r &gt;&gt; 1</code> 是向下取整，当 <code>r - l = 1</code> 时，即数组中元素只有两个时，<code>l  +  r &gt;&gt; 1 </code> 得到的结果仍为 <code>l</code>， 因此若递归进行时，比如将归并排序改为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(a, l, mid <span class="hljs-number">-1</span>), <span class="hljs-built_in">merge_sort</span>(a, mid, r);<br></code></pre></td></tr></table></figure>
<p><code>merge_sort(a, mid, r);</code> 便会进入死循环，一直进行 <code>merge_sort(a, l, r);</code>  因此 <code>l + r + 1 &gt;&gt; 1</code> 便成了向上取整， 使得 进行 <code>mege_sort(a,  r, r),</code> 便可退出递归</p>
<p>2.后续再补充</p>
<h2 id="高精度">高精度</h2>
<h3 id="高精度加法">高精度加法</h3>
<h4 id="题目描述-4">题目描述</h4>
<p>​         给定两个正整数（不含前导 0），计算它们的和。</p>
<p>​         <strong>输入格式</strong></p>
<p>​         共两行，每行包含一个整数。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共一行，包含所求的和。</p>
<p>​         <strong>数据范围</strong></p>
<p>​		  $$1≤整数长度≤100000$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">12<br>23<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">35<br></code></pre></td></tr></table></figure>
<h4 id="解析-4">解析</h4>
<p>​           之所以把数组AB逆序存储的原因，是因为最后高位进位的时候可以直接在后    			面push_back()一个，若正序存入，最高位进位，还需要向右平移；</p>
<p>​             例：a = 1234   b = 5678 ; 存进A,B为 4321  8765；（下标自左向右为0-3）</p>
<p>​             C 中存的是2196，因此需要逆序输出；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A, vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">//最高位进位</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A, B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="高精度减法">高精度减法</h3>
<h4 id="题目描述-5">题目描述</h4>
<p>​         给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。</p>
<p>​         <strong>输入格式</strong></p>
<p>​         共两行，每行包含一个整数。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共一行，包含所求的差。</p>
<p>​         <strong>数据范围</strong></p>
<p>​		  $$1≤整数长度≤100000$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">32<br>11<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">21<br></code></pre></td></tr></table></figure>
<h4 id="解析-5">解析</h4>
<p>​               和高精度加法差不多，需要注意：</p>
<ul>
<li>
<p>减法的借位处理</p>
</li>
<li>
<p>相减为负数的处理</p>
</li>
<li>
<p>前导零的处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A, vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =  A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A, vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示低位向高位的进位，又表示结果</span><br>    <span class="hljs-comment">//从个位开始减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<span class="hljs-comment">// 举个例子 654 - 638 = 16</span><br>       <span class="hljs-comment">//t = A[i] - B[i] - t;      //    </span><br>        t = A[i] - t;              <span class="hljs-comment">//   t = 4 - 0 = 4</span><br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<span class="hljs-comment">//   t = 4 - 8 = -4 </span><br>        <span class="hljs-comment">//模10是为了更方便， 若t为整数，那么 t还是不变</span><br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>)% <span class="hljs-number">10</span>);<span class="hljs-comment">//    c[0] = (-4 + 10)%10 = 6   </span><br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;          <span class="hljs-comment">//    t 为负数，进位</span><br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;               <span class="hljs-comment">//    t 为整数，无需进位</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B)) &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(A, B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(B,A);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="高精度乘法">高精度乘法</h3>
<h4 id="题目描述-6">题目描述</h4>
<p>​         给定两个非负整数（不含前导 0） A 和 B，请你计算 A×B 的值。</p>
<p>​         <strong>输入格式</strong></p>
<p>​     共两行，第一行包含整数 A，第二行包含整数 B。</p>
<p>​         <strong>输出格式</strong></p>
<p>​       共一行，包含 A×B 的值。</p>
<p>​         <strong>数据范围</strong></p>
<p>​		  $$1≤A的长度≤100000$$</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0≤B≤10000
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></span></p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">2<br>3<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">6<br></code></pre></td></tr></table></figure>
<h4 id="解析-6">解析</h4>
<ul>
<li>把B看成一个整体，和A一位一位相乘</li>
<li>乘法也有前导零，如 123 * 0 = 000</li>
<li>比如一个三位数乘二位数可能会有等于四位数(进位)的情况，而如果没有||t的话，C的长度最长就是三,||t就是用来储存A的最高位和b相乘的结果如果i已经处理到最后一位数了，但是t还有数字的话，没有||t就会忽略这些存留的t，如果有||t的话就会继续把t丢到下面的for循环中，直到t被处理输出到0位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;A, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i++)&#123;<br>        <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() &gt; i) t += b * A[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C[C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br> <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    string a; <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="高精度除法">高精度除法</h3>
<h4 id="题目描述-7">题目描述</h4>
<p>​        给定两个非负整数（不含前导 0） A，B，请你计算 A/B 的商和余数。</p>
<p>​         <strong>输入格式</strong></p>
<p>​         共两行，第一行包含整数 A，第二行包含整数 B。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共两行，第一行输出所求的商，第二行输出所求余数。</p>
<p>​         <strong>数据范围</strong></p>
<p>​		    $$1≤A的长度≤100000$$</p>
<p>​            $$0≤B≤10000$$</p>
<p>​            B一定不为0</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">32<br>11<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">21<br></code></pre></td></tr></table></figure>
<h4 id="解析-7">解析</h4>
<p>​</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>   <span class="hljs-comment">//由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字 </span><br>   <span class="hljs-comment">//因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0</span><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span> &amp;&amp; C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    string a; <span class="hljs-type">int</span> b, r;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A, b, r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt;C[i];<br>    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="前缀和与差分">前缀和与差分</h2>
<h3 id="前缀和">前缀和</h3>
<h4 id="题目描述-8">题目描述</h4>
<p>​        输入一个长度为 n的整数序列。</p>
<p>​        接下来再输入 m个询问，每个询问输入一对 l,r。</p>
<p>​        对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含两个整数 n和 m。</p>
<p>​        第二行包含 n 个整数，表示整数数列。</p>
<p>​        接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p>
<p>​         <strong>输出格式</strong></p>
<p>​         共 m 行，每行输出一个询问的结果。</p>
<p>​         <strong>数据范围</strong></p>
<p>​	      $$1≤l≤r≤n,$$</p>
<p>​          $$ 1≤n,m≤100000,$$<br>
​           $$−1000≤数列中元素的值≤1000$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3<br>6<br>10<br></code></pre></td></tr></table></figure>
<h4 id="解析-8">解析</h4>
<ul>
<li>
<p>什么是前缀和</p>
<p>原数组: a[1], a[2], a[3], a[4], a[5], …, a[n]<br>
前缀和 Si为数组的前 i项和<br>
前缀和: S[i] = a[1] + a[2] + a[3] + … + a[i]</p>
</li>
<li>
<p>一维数组求解前缀和(Si)<br>
for循环求出 每个S[i] (将 S[0] 定义为 0, 避免下标的转换)<br>
求 [l, r]中的和, 即为 S[r] - S[l-1]</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], s[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="子矩阵的和">子矩阵的和</h3>
<h4 id="题目描述-9">题目描述</h4>
<p>​         输入一个 n行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整         	 	数 x1,y1,x2,y2表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>​     	对于每个询问输出子矩阵中所有数的和。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含三个整数 n，m，q。</p>
<p>​        接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>​        接下来 q 行，每行包含四个整数 x1,y1,x2,y2表示一组询问。</p>
<p>​         <strong>输出格式</strong></p>
<p>​         共 q 行，每行输出一个询问的结果。</p>
<p>​         <strong>数据范围</strong></p>
<p>​          $$1≤n,m≤1000,$$</p>
<p>​          $$1≤q≤200000,$$<br>
​          $$1≤x1≤x2≤n,$$<br>
​          $$1≤y1≤y2≤m,$$<br>
​          $$−1000≤矩阵内元素的值≤1000$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3 4 3<br>1 7 2 4<br>3 6 2 8<br>2 1 2 3<br>1 1 2 2<br>2 1 3 4<br>1 3 3 4<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">17<br>27<br>21<br></code></pre></td></tr></table></figure>
<h4 id="解析-9">解析</h4>
<p>​           如图所示</p>
<p>​           <img src="/img/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%AD%90%E7%9F%A9%E9%98%B51.png" alt="image-20220716215723528"></p>
<p><img src="/img/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%AD%90%E7%9F%A9%E9%98%B52.png" alt="image-20220716215810735"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N], s[N][N];<br><span class="hljs-type">int</span> n, m, q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>            s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] + a[i][j] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        cout &lt;&lt; s[x2][y2] - s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="差分">差分</h3>
<h4 id="题目描述-10">题目描述</h4>
<p>​         输入一个长度为 n 的整数序列。</p>
<p>​        接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r]     		之间的每个数加上 c。</p>
<p>​       请你输出进行完所有操作后的序列。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含两个整数 n 和 m。</p>
<p>​        第二行包含 n个整数，表示整数序列。</p>
<p>​        接下来 m 行，每行包含三个整数 l，r，c表示一个操作。</p>
<p>​         <strong>输出格式</strong></p>
<p>​         共一行，包含 n 个整数，表示最终序列。</p>
<p>​         <strong>数据范围</strong></p>
<p>​          $$1≤n,m≤100000,$$</p>
<p>​          $$1≤l≤r≤ n$$<br>
​          $$−1000≤c≤1000$$<br>
​          $$−1000≤整数序列中元素的值≤1000$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3 4 5 3 4 2<br></code></pre></td></tr></table></figure>
<h4 id="解析-10">解析</h4>
<p>​          类似于数学中的求导和积分，<strong>差分可以看成前缀和的逆运算。</strong></p>
<p>​           <strong>差分数组：</strong></p>
<p>​           首先给定一个原数组a[1], a[2], a[3]… a[n];</p>
<p>​           然后我们构造一个数组 b[1] ,b[2] , b[3]… b[i];</p>
<p>​           使得 a[i] = b[1] + b[2 ]+ b[3] +…+ b[i]</p>
<p>​           也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一 个a[i]都是b数 			组中从头开始的一段区间和。</p>
<p>​           考虑如何构造差分b数组？</p>
<p>​           最为直接的方法</p>
<p>​           <code>a[0 ]= 0;</code></p>
<p>​          <code>b[1] = a[1] - a[0];</code></p>
<p>​          <code>b[2] = a[2] - a[1];</code></p>
<p>​          <code>b[3] =a [3] - a[2];</code></p>
<p>​          <code>b[n] = a[n] - a[n-1];</code></p>
<p>​          <strong>作用</strong>：</p>
<p>​          给定区间<code>[l ,r ]</code>,让我们把a数组中的<code>[ l, r ]</code>区间中的每一个数都加上c,即 <code>a[l] + c , a[l+1] + c , a[l+2]</code>   		<code>+ c ... a[r] + c;</code></p>
<p>​        暴力做法是<code>for</code>循环<code>l</code>到<code>r</code>区间，时间复杂度<code>O(n)</code>，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变   		成<code>O(n*m)</code>。有没有更高效的做法吗? 考虑差分做法。</p>
<p>​		始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。</p>
<p>​		首先让差分b数组中的 <code>b[l] + c</code> ,a数组变成 <code>a[l] + c ,a[l+1] + c... a[n] + c</code>;</p>
<p>​		然后我们打个补丁，<code>b[r+1] - c</code>, a数组变成 <code>a[r+1] - c,a[r+2] - c...a[n] - c</code>;</p>
<p><img src="/img/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%B7%AE%E5%88%86.png" alt="第一讲差分"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], b[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        b[i] = a[i] - a[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//构造差分数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--) &#123;<br>        <span class="hljs-type">int</span> l, r, c;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        b[l] += c;<br>        b[r + <span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        a[i] = b[i] + a[i - <span class="hljs-number">1</span>];<br>        cout &lt;&lt; a[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="差分矩阵">差分矩阵</h3>
<h4 id="题目描述-11">题目描述</h4>
<p>​         输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五   		个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角 		坐标和右下角坐标。</p>
<p>​		每个操作都要将选中的子矩阵中的每个元素的值加上c。</p>
<p>​		请你将进行完所有操作后的矩阵输出。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含整数 n,m,q。</p>
<p>​		接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>​		接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。</p>
<p>​         <strong>输出格式</strong></p>
<p>​         共 n 行，每行 m个整数，表示所有操作进行完毕后的最终矩阵。</p>
<p>​         <strong>数据范围</strong></p>
<p>​          $$1≤n,m≤1000,$$</p>
<p>​          $$1≤q≤100000,$$</p>
<p>​          $$1≤x1≤x2≤n$$<br>
​          $$1≤y1≤y2≤m$$<br>
​          $$−1000≤c≤1000$$<br>
​          $$−1000≤矩阵内元素的值≤1000$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3 4 3<br>1 2 2 1<br>3 2 2 1<br>1 1 1 1<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">2 3 4 1<br>4 3 4 1<br>2 2 2 2<br></code></pre></td></tr></table></figure>
<h4 id="解析-11">解析</h4>
<ul>
<li><strong>二维差分</strong></li>
</ul>
<p>​          如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的 		 值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑<strong>二		维 差 分。</strong></p>
<pre><code>	$$a[ ][ ]$$数组是$$b[][]$$数组的前缀和数组，那么$$b[][]$$数组是$$a[ ][ ]$$数组的差分数组
</code></pre>
<p>​		原数组：$$ a[i][j]$$</p>
<p>​       我们去构造差分数组： $$b[i][j]$$</p>
<p>​       使得a数组中$$a[i][j]$$是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的 		和。</p>
<p><img src="/img/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5.png" alt="image-202207162158107325"></p>
<p>​       根据上图可得出：</p>
<pre><code>  假定我们已经构造好了b数组，类比一维差分，我们执行以下操作来使被选中的子矩阵中的每个元素的值加上c
   `b[x1][y1] - = c;`
</code></pre>
<p>​		<code>b[x1][y2+1] - = c;</code></p>
<p>​       <code>b[x2+1][y1] - = c;</code></p>
<p>​		<code>b[x2+1][y2+1] + = c;</code></p>
<p>​        <strong><u>最重要的一步</u></strong>：我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让		以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 <code>c=a[i][j]</code>，等价 于原数组a中(i,j) 		到(i,j)范围内 加上了 <code>a[i][j]</code> ,因此执行n*m次插入操 		作，就成功构建了差分b数组.</p>
<p>​</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N], b[N][N];<br><span class="hljs-type">int</span> n, m, q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span> </span>&#123;<br><br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>            <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2, c;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(x1, y1, x2, y2, c);<br>    &#125;<br>    <span class="hljs-comment">// 求前缀和，因为a[i][j] = b[1][1]+....+b[i][j]</span><br>    <span class="hljs-comment">//为了节省空间开销，不设s[][]数组， s[i][j] = s[i - 1][j] </span><br>    <span class="hljs-comment">// + s[i][j - 1] - s[i - 1][j -1] + b[i][j];</span><br>    <span class="hljs-comment">//因为s[i][j] = b[i][j], 故使用 +=</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            b[i][j] += b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cout &lt;&lt; b[i][j] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="双指针算法">双指针算法</h2>
<h3 id="最长连续不重复子序列">最长连续不重复子序列</h3>
<h4 id="题目描述-12">题目描述</h4>
<p>​         给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含整数 n。</p>
<p>​       第二行包含 n 个整数（均在 0∼105范围内），表示整数序列。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<p>​         <strong>数据范围</strong></p>
<p>​          $$1≤n≤10^5$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">5<br>1 2 2 3 5<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure>
<h4 id="解析-12">解析</h4>
<p>​       1.遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针<code>[j, i]</code>维护的是以a[i]结尾的最长连续不重复子序列， 		长度为<code>i - j + 1,</code> 将这一长度与r 的较大者更新给r。</p>
<p>​       2.对于每一个i，如何确定j的位置：由于<code>[j, i - 1]</code>是前一步得到的最长连续不重复子序列，所以如果<code>[j, i]</code>中有重		复元素,一定是<code>a[i]</code>，因此右移<strong>j</strong>直到<code>a[i]</code>不重复为止（由于<code>[j, i - 1]</code>已经是前一步的最优解，此时j只可能右移以		剔除重复元素<code>a[i]</code>，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。<br>
​		3.用数组s记录子序列<code>a[j ~ i]</code>中各元素出现次数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], s[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        s[a[i]]++;<br>        <span class="hljs-comment">//只有不满足条件，j才会向右移</span><br>        <span class="hljs-keyword">while</span>(j &lt; i &amp;&amp; s[a[i]] &gt; <span class="hljs-number">1</span>) s[a[j++]] --;<br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数组元素的目标和">数组元素的目标和</h3>
<h4 id="题目描述-13">题目描述</h4>
<p>​        给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。</p>
<p>​        数组下标从 0 开始。</p>
<p>​       请你求出满足 A[i]+B[j]=x的数对 (i,j)。</p>
<p>​       数据保证有唯一解。</p>
<p>​        <strong>输入格式</strong></p>
<p>​         第一行包含三个整数 n,m,x分别表示 A 的长度，B 的长度以及目标值 x。</p>
<p>​        第二行包含 n 个整数，表示数组 A。</p>
<p>​        第三行包含 m 个整数，表示数组 B。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共一行，包含两个整数 i 和 j。</p>
<p>​         <strong>数据范围</strong></p>
<p>​         数组长度不超过 $$10^5$$。</p>
<p>​         同一数组内元素各不相同。<br>
​          1≤数组元素≤10^9$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">4 5 6<br>1 2 4 7<br>3 4 6 8 9<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1 1<br></code></pre></td></tr></table></figure>
<h4 id="解析-13">解析</h4>
<p>​         i从 0开始 从前往后遍历<br>
​         j从 m - 1开始 从后向前遍历</p>
<p>​         和纯暴力的$$O(n^2)$$算法的区别就在于j指针不会回退</p>
<p>​</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], b[N];<br><span class="hljs-type">int</span> n, m, x;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j--;<br>        <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp;a[i] + b[j] == x) cout &lt;&lt;i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="判断子序列">判断子序列</h3>
<h4 id="题目描述-14">题目描述</h4>
<p>​        给定一个长度为 n 的整数序列 <code>a1,a2,…,an</code> 以及一个长度为 mm 的整数序列 <code>b1,b2,…,bm</code></p>
<p>​        请你判断 a 序列是否为 b 序列的子序列。</p>
<p>​       子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 <code>&#123;a1,a3,a5&#125;</code>是序列 <code>&#123;a1,a2,a3,a4,a5&#125;</code>的一个子序   		列。</p>
<p>​        <strong>输入格式</strong></p>
<p>​         第一行包含两个整数 n,m</p>
<p>​        第二行包含 n个整数，表示 <code>a1,a2,…,an</code></p>
<p>​        第三行包含 m 个整数，表示 <code>b1,b2,…,bm</code></p>
<p>​         <strong>输出格式</strong></p>
<p>​        如果 a 序列是 b 序列的子序列，输出一行 <code>Yes</code>。</p>
<p>​		否则，输出 <code>No</code></p>
<p>​         <strong>数据范围</strong></p>
<p>​         $$1≤n≤m≤10^5$$</p>
<p>​        $$−10^9≤ai,bi≤10^9$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3 5<br>1 3 5<br>1 2 3 4 5<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Yes<br></code></pre></td></tr></table></figure>
<h4 id="解析-14">解析</h4>
<p>​       1. j指针用来扫描整个b数组，i指针用来扫描a数组。若发现a[i]==b[j]，则让i指针后移一位。</p>
<p>​       2.整个过程中，j指针不断后移，而i指针只有当匹配成功时才后移一位，若最后若i==n，则说明匹配成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[j]);<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; n&amp;&amp;a[i] == b[j])  i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i == n) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="位运算">位运算</h2>
<h3 id="二进制中1的个数">二进制中1的个数</h3>
<h4 id="题目描述-15">题目描述</h4>
<p>​        给定一个长度为 n的数列，请你求出数列中每个数的二进制表示中 1的个数。</p>
<p>​        <strong>输入格式</strong></p>
<p>​         第一行包含整数 n。</p>
<p>​         第二行包含 n 个整数，表示整个数列。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数</p>
<p>​         <strong>数据范围</strong></p>
<p>​         $$1≤n≤100000$$</p>
<p>​        $$0≤数列中元素的值≤10^9$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">5<br>1 2 3 4 5<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1 1 2 1 2<br></code></pre></td></tr></table></figure>
<h4 id="解析-15">解析</h4>
<p>​     <strong>(lowbit)</strong> O(nlogn)<br>
​     使用lowbit操作，进行，每次lowbit操作截取一个数字最后一个1后面的所有位，每次减去lowbit得到的数字，直到数字     	 减到0，就得到了最终1的个数，</p>
<p>​      <strong>lowbit原理</strong><br>
​     根据计算机负数表示的特点，如一个数字原码是10001000，他的负数表示形式是补码，就是反码+1，反码01110111，       	加一则是01111000，二者按位与得到了1000，就是我们想要的lowbit操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x; cin&gt;&gt;x;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)  x-=<span class="hljs-built_in">lowbit</span>(x), res++;<br>        cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="离散化">离散化</h2>
<h3 id="区间和">区间和</h3>
<h4 id="题目描述-16">题目描述</h4>
<p>​        假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p>​        现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加c。</p>
<p>​       接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r][l,r] 之间的所有数的和。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含两个整数 n 和 m。</p>
<p>​       接下来 n 行，每行包含两个整数x 和 c。</p>
<p>​       再接下来 m 行，每行包含两个整数 l 和 r。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共 m行，每行输出一个询问中所求的区间内数字和。</p>
<p>​         <strong>数据范围</strong></p>
<p>​    −$$10^9≤x≤10^9$$</p>
<p>​     $$1≤n,m≤10^5$$<br>
​    $$−10^9≤l≤r≤10^9$$</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mn>10000</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">−10000≤c≤10000
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">10000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></span></p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">8<br>0<br>5<br></code></pre></td></tr></table></figure>
<h4 id="解析-16">解析</h4>
<p>​    <img src="/img/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%8C%BA%E9%97%B4%E5%92%8C.png" alt="第一讲区间和"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N], s[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; alls;<br>vector&lt;PII&gt; add, query;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x, c;<br>        cin &gt;&gt; x &gt;&gt; c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x, c&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(l);<br>        alls.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item: add) &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);<br>        a[x] += item.second;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= alls.<span class="hljs-built_in">size</span>(); i ++ ) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : query)<br>    &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(item.first), r = <span class="hljs-built_in">find</span>(item.second);<br>        cout &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="区间合并">区间合并</h2>
<h3 id="区间合并-2">区间合并</h3>
<h4 id="题目描述-17">题目描述</h4>
<p>​        给定 n 个区间 [li,ri]，要求合并所有有交集的区间。</p>
<p>​       注意如果在端点处相交，也算有交集。</p>
<p>​      输出合并完成后的区间个数。</p>
<p>​      例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。</p>
<p>​        <strong>输入格式</strong></p>
<p>​        第一行包含整数 n。</p>
<p>​        接下来 n 行，每行包含两个整数 l 和 r。</p>
<p>​         <strong>输出格式</strong></p>
<p>​        共一行，包含一个整数，表示合并区间完成后的区间个数</p>
<p>​         <strong>数据范围</strong></p>
<p>​        $$1≤n≤100000$$</p>
<p>​     $$−10^9≤li≤ri≤10^9$$</p>
<p>​          <strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">5<br>1 2<br>2 4<br>5 6<br>7 8<br>7 9<br></code></pre></td></tr></table></figure>
<p>​    	<strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure>
<h4 id="解析-17">解析</h4>
<ul>
<li>以左端点进行排序，每次让下一个集合与该集合的右端点进行比较即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">//存答案</span><br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//[st,ed]为当前正在维护的区间  </span><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>    <span class="hljs-comment">//把最后的区间加入答案中</span><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    vector&lt;PII&gt; segs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        segs.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>    &#125;<br><br>    <span class="hljs-built_in">merge</span>(segs);<br><br>    cout &lt;&lt; segs.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">至安</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/12/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">http://example.com/2022/07/12/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">从前慢</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">算法基础</a></div><div class="post_share"><div class="social-share" data-image="/img/any2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/28/%E7%AC%AC%E9%9B%B6%E5%91%A8%E5%A4%8D%E7%9B%98/"><img class="prev-cover" src="/img/any3.webp" onerror="onerror=null;src='/img/any3.webp'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第零周复盘</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/11/%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/"><img class="next-cover" src="/img/u.jpg" onerror="onerror=null;src='/img/any3.webp'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从前慢</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/u.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">至安</div><div class="author-info__description">至安，你抵达安宁了吗？</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZHIAN"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZHIAN" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2981115824@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://pic1.zhimg.com/v2-094497df7b05d6db0e7da8c808384fe4_r.jpg" target="_blank" title="picture"><i class="fa-solid fa-image"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">你好</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">第一讲 基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-2"><span class="toc-number">1.1.1.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">情况分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">第k个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">逆序对的数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">1.3.1.</span> <span class="toc-text">数的范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">数的三次方根</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-3"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">高精度加法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-4"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">高精度减法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-5"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">高精度乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-6"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">高精度除法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-7"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="toc-number">1.6.</span> <span class="toc-text">前缀和与差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.6.1.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-8"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="toc-number">1.6.2.</span> <span class="toc-text">子矩阵的和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-9"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">差分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-10"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.4.</span> <span class="toc-text">差分矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-11"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">双指针算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.7.1.</span> <span class="toc-text">最长连续不重复子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-12"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-12"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">1.7.2.</span> <span class="toc-text">数组元素的目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-13"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-13"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.7.3.</span> <span class="toc-text">判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-14"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-14"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.8.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.8.1.</span> <span class="toc-text">二进制中1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-15"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-15"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.9.1.</span> <span class="toc-text">区间和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-16"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-16"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">1.10.</span> <span class="toc-text">区间合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6-2"><span class="toc-number">1.10.1.</span> <span class="toc-text">区间合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-17"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-17"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/hexo%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/" title="hexo命令合集"><img src="/img/any2.webp" onerror="this.onerror=null;this.src='/img/any3.webp'" alt="hexo命令合集"/></a><div class="content"><a class="title" href="/2022/08/28/hexo%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/" title="hexo命令合集">hexo命令合集</a><time datetime="2022-08-28T10:34:52.000Z" title="发表于 2022-08-28 18:34:52">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/%E7%AC%AC%E9%9B%B6%E5%91%A8%E5%A4%8D%E7%9B%98/" title="第零周复盘"><img src="/img/any3.webp" onerror="this.onerror=null;this.src='/img/any3.webp'" alt="第零周复盘"/></a><div class="content"><a class="title" href="/2022/08/28/%E7%AC%AC%E9%9B%B6%E5%91%A8%E5%A4%8D%E7%9B%98/" title="第零周复盘">第零周复盘</a><time datetime="2022-08-28T10:18:37.000Z" title="发表于 2022-08-28 18:18:37">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/12/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="第一讲 基础算法"><img src="/img/any2.webp" onerror="this.onerror=null;this.src='/img/any3.webp'" alt="第一讲 基础算法"/></a><div class="content"><a class="title" href="/2022/07/12/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="第一讲 基础算法">第一讲 基础算法</a><time datetime="2022-07-12T09:39:07.000Z" title="发表于 2022-07-12 17:39:07">2022-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/" title="从前慢"><img src="/img/u.jpg" onerror="this.onerror=null;this.src='/img/any3.webp'" alt="从前慢"/></a><div class="content"><a class="title" href="/2022/07/11/%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/" title="从前慢">从前慢</a><time datetime="2022-07-11T01:40:34.000Z" title="发表于 2022-07-11 09:40:34">2022-07-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/any2.webp')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 至安</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="xxxx"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>